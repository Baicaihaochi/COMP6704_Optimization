NAME: berlin52
TYPE: TSP
                  # 从 A 到 B 的距离 = 从 B 到 A 的距离（即d_ij=d_ji），且不允许重复访问。
COMMENT: 52 locations in Berlin (Groetschel)
DIMENSION: 52
              # 城市数量 n=52, 由数学家 Martin Grötschel 提出的 52 个柏林位置（实际坐标不代表真实地理，仅为数学建模用）。
EDGE_WEIGHT_TYPE: EUC_2D
   # 边的权重（即城市间距离）按 二维欧氏距离（Euclidean distance） 计算，并四舍五入取整, 必须四舍五入。
NODE_COORD_SECTION
         # <城市编号> <x 坐标> <y 坐标>
1 565.0 575.0
2 25.0 185.0
3 345.0 750.0
4 945.0 685.0
5 845.0 655.0
6 880.0 660.0
7 25.0 230.0
8 525.0 1000.0
9 580.0 1175.0
10 650.0 1130.0
11 1605.0 620.0
12 1220.0 580.0
13 1465.0 200.0
14 1530.0 5.0
15 845.0 680.0
16 725.0 370.0
17 145.0 665.0
18 415.0 635.0
19 510.0 875.0
20 560.0 365.0
21 300.0 465.0
22 520.0 585.0
23 480.0 415.0
24 835.0 625.0
25 975.0 580.0
26 1215.0 245.0
27 1320.0 315.0
28 1250.0 400.0
29 660.0 180.0
30 410.0 250.0
31 420.0 555.0
32 575.0 665.0
33 1150.0 1160.0
34 700.0 580.0
35 685.0 595.0
36 685.0 610.0
37 770.0 610.0
38 795.0 645.0
39 720.0 635.0
40 760.0 650.0
41 475.0 960.0
42 95.0 260.0
43 875.0 920.0
44 700.0 500.0
45 555.0 815.0
46 830.0 485.0
47 1170.0 65.0
48 830.0 610.0
49 605.0 625.0
50 595.0 360.0
51 1340.0 725.0
52 1740.0 245.0
EOF

# 坐标单位：无单位，但按欧氏距离计算（EDGE_WEIGHT_TYPE: EUC_2D 表示使用四舍五入后的整数距离：
# 最优解长度：7542（由 Concorde 等精确算法验证）。
# 数据来源：由 M. Grötschel 提供，收录于 TSPLIB（由 G. Reinelt 维护）。

# 步骤 1：读取坐标：得到一个字典

# 步骤 2：计算距离矩阵 D[i][j]
# import math
# def euclidean_distance(c1, c2):
#     return round(math.sqrt((c1[0] - c2[0])**2 + (c1[1] - c2[1])**2))
# 重要：D[i][j] 必须是 整数，因为 TSPLIB 的 EUC_2D 规定四舍五入。

# 步骤 3：目标函数。目标是最小化总距离：
# min i=1∑52 j=1∑52 D[i][j]⋅x_ij

# 验证实现是否正确: 计算已知最优路径的总距离是否为 7542。最优路径的城市访问顺序（1-based）为（闭合回路，最后一站回到 1）：
# 1 → 48 → 31 → 44 → 20 → 50 → 11 → 51 → 10 → 9 → 8 → 3 → 2 → 7 → 42 → 17 → 18 → 21 → 23 → 22 → 19 → 43 → 32 → 36 → 35 → 34 → 33 → 41 → 45 → 46 → 15 → 5 → 6 → 4 → 25 → 24 → 47 → 13 → 26 → 27 → 28 → 12 → 39 → 38 → 40 → 37 → 16 → 29 → 30 → 14 → 49 → 1